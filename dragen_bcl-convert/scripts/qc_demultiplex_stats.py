#!/usr/bin/env python3
"""
Control the Quality of DRAGEN BCL-convert. Check the yield per index and 
reports several statistics from `Reports/Demultiplex_Stats.csv` generated by
`dragen --bcl-conversion-only`.

USAGE: qc_demultiplex_stats.py --help # And the rest is handled by `argparse`
"""

import sys
import os
import argparse
import logging
import pandas as pd
import plotly
import plotly.graph_objects as go
import seaborn as sns
import matplotlib.pyplot as plt


__version__ = "0.1"


def parse_args():
    """
    Parse command-line options
    """
    parser = argparse.ArgumentParser(description="Quality Control of BCL-convert's Demultiplex_Stats")
    parser.add_argument('--file', '-f', nargs='?', default='Demultiplex_Stats.csv', 
                        help="Dragen BCL-convert demultiplexing report. Default='Demultiplex_Stats.csv'")
    parser.add_argument('--threshold', '-t', default=300_000_000,
                        help="Minimum threshold value for number of counts. Default='3000_000_000'")
    parser.add_argument('--logging-level', '-l', dest='level', default='info',
                        help="Logging level (str), can be 'debug', 'info', 'warning'. Default='info'")
    return parser.parse_args()


def configure_logging(level):
    """
    Set logging level, based on the level names of the `logging` module.
    - level (str): 'debug', 'info' or 'warning'
    """
    if level == 'debug':
        level_name = logging.DEBUG
    elif level == 'info':
        level_name = logging.INFO
    else:
        level_name = logging.WARNING
    logging.basicConfig(level=level_name, 
                        format='[%(asctime)s] %(levelname)s: %(message)s', 
                        datefmt='%Y-%m-%d@%H:%M:%S')


def add_expected_reads(df, seq_fractions=None):
    """
    Calulcate the number of expected reads based on the total number of reads
    and the sequencing fractions, and add as a new column to df. If sequencing 
    fraction is None equal distribution amongst samples is assumed.
    - `df`: 'Demultiplex_Stats.csv' as a Pandas DataFrame
    - `seq_fractions`: Sequencing fractions (from SamplePools)
    - return: `df` grouped by 'SampleID', with additional columns ['# Lanes', 'Fractions', 'Expected']
    """
    total_rows  = len(df)
    total_reads = df['# Reads'].sum()
    if seq_fractions is None:
        # Assume equal distribution of reads amongst each sample across
        # all sequencing lanes on which the sample is present
        # 
        df['# Lanes']   = 1
        df['Fractions'] = 1 / total_rows
        df['Expected']  = total_reads * df['Fractions']
        df_group = df.groupby('SampleID').sum(['# Reads', '% Reads', '# Lanes', 'Fractions']).reset_index()
        df_group['Mean % Perfect Index Reads']  = df['% Perfect Index Reads'] / df['# Lanes']
    else:
        pass # TODO: Get df['Fraction'] from external source (the lab)
    return df_group[['SampleID', 'Expected', '# Reads', 'Mean % Perfect Index Reads', '# Lanes', 'Fractions']]


def plot_plotly_bar(df, threshold, outfile='demux_reads_per_sample-bar.html'):
    """
    Plot bar chart as a HTML file using Plotly
    - `df`: Pandas DataFrame with columns ['SampleID', 'Expected', '# Reads']
    - `threshold`: value to mark as threshold.
    - `outfile`  : Name of output file. Default='demux_reads_per_sample-bar.html'
    - Returns: 0
    """
    try:
        df[['SampleID', 'Expected', '# Reads']]
    except KeyError as e:
        logging.error(f"Required columns not found: {e}")
    except Exception as e:
        logging.error(f"Unexpected error: {e}")
    else:
        observed = go.Bar(x=df['SampleID'], y=df['# Reads'], name='Observed',
                        marker_color=['red' if val < threshold else 'orange' for val in df['# Reads']])
        expected = go.Bar(x=df['SampleID'], y=df['Expected'], name='Expected', marker_color='grey')
        fig = go.Figure([observed, expected])
        fig.update_layout(title={'text': 'Number of reads per SampleID', 'x': 0.5, 'xanchor': 'center'},
                        xaxis_title='SampleID',
                        yaxis_title='Number of Reads')
        fig.update_traces(marker_line_color='rgb(8,48,107)',
                        marker_line_width=1.5,
                        opacity=0.6)
        fig.add_hline(y=threshold, line=dict(color="red", width=1, dash="dashdot"))
        # fig.write_image('demux_reads_per_sample-bar.png') # requires kaleido which depends on Google Chrome
        plotly.offline.plot(fig, filename=outfile)
        return fig


def plot_plotly_box(df, threshold, outfile='demux_reads_per_sample-box.html'):
    """
    Plot bar chart as a HTML file using Plotly
    - `df`: Pandas DataFrame with columns ['SampleID', 'Expected', '# Reads']
    - `threshold`: value to mark as threshold.
    - `outfile`  : Name of output file. Default='demux_reads_per_sample-bar.html'
    - Returns: 0
    """
    try:
        df[['SampleID', 'Expected', '# Reads']]
    except KeyError as e:
        logging.error(f"Required columns not found: {e}")
    except Exception as e:
        logging.error(f"Unexpected error: {e}")
    else:
        box = go.Box(y=df['# Reads'], name='Number of reads', 
                    boxmean='sd', boxpoints='all', jitter=0.2)
        fig = go.Figure([box])
        fig.update_layout(title={'text': 'Number of reads per SampleID', 'x': 0.5, 'xanchor': 'center'}, 
                          yaxis_title='Number of Reads')
        fig.update_traces(marker_color='orange', 
                          marker_line_color='rgb(8,48,107)', 
                          marker_line_width=1.5,
                          opacity=0.6)
        fig.add_hline(y=threshold, line=dict(color="red", width=1, dash="dashdot"))
        # fig.write_image('demux_reads_per_sample-bar.png') # requires kaleido which depends on Google Chrome
        plotly.offline.plot(fig, filename=outfile)
        return fig


def write_html_report(df, fc_short):
    """
    Write HTML report from data in `df`.
    - `df`: Pandas DataFrame.
    - Returns: HTML file.
    """
    css = """
            html body {
                background: #f8f9f9;
                font-size: 11px;
            }
    """
    out_html = f"demux_report.html"
    title    = f"Demultiplex Report"

    with open(out_html, 'w') as fh:
        fh.write('<!doctype html>\n<html>\n\t<head>\n')
        fh.write(f'\t\t<title>{title}</title>\n\t\t<meta charset="UTF-8">\n')
        fh.write(f'\t\t<style type="text/css">{css}\t\t</style>\n')
        fh.write('\t</head>\n\t<body>\n')
        fh.write(f'\t\t<h1>{title}</h1>\n\t\t')
        #fh.write(fig1.to_html(full_html=False, include_plotlyjs='cdn'))
        fh.write('\n\t</body>\n</html>')


def plot_seaborn_bar(df, threshold, outfile='demux_reads_per_sample-bar.png'):
    """
    Plot bar chart as a PNG file using Seaborn.
    - `df`: Pandas DataFrame with columns ['SampleID', 'Expected', '# Reads']
    - `threshold`: value to mark as threshold.
    - `outfile`  : Name of output file. Default='demux_reads_per_sample-bar.png'
    - Returns: 0
    """
    bar_colors = ['red' if val < threshold else 'orange' for val in df['# Reads']]
    plt.figure(figsize=(14, 6))
    sns.barplot(data=df, x='SampleID', y='# Reads', palette=bar_colors, edgecolor='navy', alpha=0.6)
    plt.axhline(threshold, color='grey', linestyle='dashed', linewidth=1)
    plt.title('Number of reads per SampleID', fontsize=16)
    plt.xlabel('SampleID')
    plt.ylabel('Number of Reads')
    plt.xticks(rotation=90)
    plt.tight_layout()
    plt.savefig(outfile)
    return 0


def plot_ascii_bar(data, threshold):
    """
    Plot bar chart of `dataframe` using ASCII art.
    Code and text  by Alex Chan from [Drawing ASCII bar charts]
    (https://alexwlchan.net/2018/ascii-bar-charts/)
    - `data` : List of tuples [('Labels', 'Counts'), ('Labels', 'Counts'),...]
    - Returns: (str) ASCII art bar plot
    """
    RED   = "\033[31m"
    RESET = "\033[0m"
    bar_plot_str = ''
    max_value = max(count for _, count in data)
    increment = max_value / 25
    longest_label_length = max(len(label) for label, _ in data)

    for label, count in data:
        # ASCII block elements are chunks of 8: work out how many fractions
        # of 8 we need https://en.wikipedia.org/wiki/Block_Elements
        #
        bar_chunks, remainder = divmod(int(count * 8 / increment), 8)

        # First draw the full width chunks
        #
        bar = '█' * bar_chunks

        # Then add the fractional part. The Unicode code points for block 
        # elements are 8/8, 7/8, 6/8, ... , so we need to work backwards.
        #
        if remainder > 0:
            bar += chr(ord('█') + (8 - remainder))

        # If the bar is empty, add a left one-eighth block
        #
        bar = bar or  '▏'
        if count < threshold:
            bar_plot_str += f"{RED}{label.rjust(longest_label_length)} ▏ {count:#4d} {bar}{RESET}\n"
        else:
            bar_plot_str += f"{label.rjust(longest_label_length)} ▏ {count:#4d} {bar}\n"

    return bar_plot_str


def main():
    """
    Main function
    """
    args = parse_args()
    configure_logging(args.level)
    logging.info(f"{__file__} {vars(args)}")

    df_demux_stats0 = pd.read_csv(args.file)
    df_demux_stats0['SampleID'] = df_demux_stats0['SampleID'].astype(str)
    df_demux_stats = add_expected_reads(df_demux_stats0)
    logging.debug(df_demux_stats)

    # Print bar charts of read counts per sample to an HTML file and STDOUT
    # PNG output to PNG using Plotly has a dependency on Google Chrome!
    #
    logging.info(f"Creating bar charts")
    workdir = os.path.dirname(args.file)
    os.chdir(workdir)
    plot_seaborn_bar(df_demux_stats, threshold=args.threshold)
    fig_bar = plot_plotly_bar(df_demux_stats, threshold=args.threshold)
    fig_box = plot_plotly_box(df_demux_stats, threshold=args.threshold)

    logging.info(f"Distribution of the number of reads per sample\n")
    data = [] # Create list of tuples for `plot_ascii_bar(list_oftuples)`
    for _, row in df_demux_stats.iterrows():
        data.append((row['SampleID'], row['# Reads']))
    logging.info("\n" + plot_ascii_bar(data, threshold=args.threshold) + "\n")

    # Get the samples that have counts below the threshold value
    #
    logging.info(f"Samples below the threshold value of {args.threshold} reads")
    logging.info(df_demux_stats[df_demux_stats['# Reads'] < args.threshold])


if __name__ == '__main__':
    sys.exit(main())
